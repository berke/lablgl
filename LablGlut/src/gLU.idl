/* camlglu.idl 
   Derived from GL/glu.h.  Changes copyright (c) 2003 Issac Trotts. */

/* 
** Original comments from glu.h:
**
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: This software was created using the
** OpenGL(R) version 1.2.1 Sample Implementation published by SGI, but has
** not been independently verified as being compliant with the OpenGL(R)
** version 1.2.1 Specification.
*/

#include "glu_constants.idl"

quote(C,"#include <GL/gl.h>");
quote(C,"#include <GL/glu.h>");
quote(C,"#include <assert.h>");
quote(C,"#include <string.h>");
quote(C,"typedef void* glu_nurbs;");
quote(C,"typedef void* glu_quadric;");
quote(C,"typedef void* glu_tesselator;");
quote(C,"typedef void* glu_triangulator;");
quote(C,"typedef void (*glu_callback)(void);");
quote(C,"typedef GLint idlglu_errcode;");
quote(C,"typedef GLint idlglu_tf_errcode;");
quote(C,"typedef struct caml_bigarray caml_bigarray;");

typedef [abstract] void* glu_nurbs;
typedef [abstract] void* glu_quadric;
typedef [abstract] void* glu_tesselator;
typedef [abstract] void* glu_triangulator;

typedef [abstract,mltype("unit->unit")] void* glu_callback; 


quote(mlmli, "open Bigarray");
quote(mlmli, "type f64ba_t = (float, float64_elt, c_layout) Array1.t");

/* zero on sucess */
typedef [errorcode, errorcheck(idlglu_errcode_check)] int idlglu_errcode;
/* GL_TRUE on success */
typedef [errorcode, errorcheck(idlglu_tf_errcode_check)] int idlglu_tf_errcode;
quote(C,"
    void idlglu_errcode_check(idlglu_errcode ecode) 
    {
        if(ecode != 0) {
            char buf[80*40];
            strncpy(buf,gluErrorString(ecode),sizeof(buf)-1);
            failwith(buf);
        }
    }
");

quote(C,"
    void idlglu_tf_errcode_check(idlglu_tf_errcode ecode) 
    {
        if(ecode == GL_FALSE) {
            failwith(\"GLU call (idlglu)\");
        }
    }
");

void gluBeginCurve (glu_nurbs nurb);
void gluBeginSurface (glu_nurbs nurb);
void gluBeginTrim (glu_nurbs nurb);

// Use Obj.magic to user other types of bigarrays with gluBuild*
idlglu_errcode gluBuild1DMipmapLevels (int target, int internalFormat, int width, int format, int type, int level, int base, int max, [in,bigarray] void *data);
idlglu_errcode gluBuild1DMipmaps (int target, int internalFormat, int width, int format, int type, [in,bigarray] void *data);
idlglu_errcode gluBuild2DMipmapLevels (int target, int internalFormat, int width, int height, int format, int type, int level, int base, int max, [in,bigarray] void *data);
idlglu_errcode gluBuild2DMipmaps (int target, int internalFormat, int width, int height, int format, int type, [in,bigarray] void *data);
idlglu_errcode gluBuild3DMipmapLevels (int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int base, int max, [in,bigarray] void *data);
idlglu_errcode gluBuild3DMipmaps (int target, int internalFormat, int width, int height, int depth, int format, int type, [in,bigarray] void *data);
unsigned char gluCheckExtension ([string] char *extName, [string] char *extString);
void gluCylinder (glu_quadric quad, double base, double top, double height, int slices, int stacks);
void gluDeleteNurbsRenderer (glu_nurbs nurb);
void gluDeleteQuadric (glu_quadric quad);
void gluDeleteTess (glu_tesselator tess);
void gluDisk (glu_quadric quad, double inner, double outer, int slices, int loops);
void gluEndCurve (glu_nurbs nurb);
void gluEndPolygon (glu_tesselator tess);
void gluEndSurface (glu_nurbs nurb);
void gluEndTrim (glu_nurbs nurb);
    [string] const char * gluErrorString (unsigned int error);
void gluGetNurbsProperty (glu_nurbs nurb, unsigned int property, [out,ref] float* data);
    [string] const char * gluGetString (unsigned int name);
void gluGetTessProperty (glu_tesselator tess, unsigned int which, [out,ref] double* data);
void gluLoadSamplingMatrices (glu_nurbs nurb, [in,bigarray] float model[16],
    [in,bigarray] float perspective[16], [in,*int32,bigarray] int view[16]);
void gluLookAt (double eyeX, double eyeY, double eyeZ, double centerX, double centerY, double centerZ, double upX, double upY, double upZ);
glu_nurbs gluNewNurbsRenderer (void); // Should throw an exception if it returns null
glu_quadric gluNewQuadric (void); // Should throw an exception if it returns null
glu_tesselator gluNewTess (void); // Should throw an exception if it returns null
void gluNextContour (glu_tesselator tess, unsigned int type);

// FIXME: Need to be able to handle multiple nurbs callbacks.
quote(C, "static void c_nurbs_callback()                                   ");
quote(C, "{                                                                    ");
quote(C, "      callback(*caml_named_value(\"ocamlglu_nurbs_cb\"), Val_unit);  ");
quote(C, "}                                                                    ");
quote(mli, "val gluNurbsCallback : glu_nurbs -> int -> glu_callback -> unit");

void _gluNurbsCallback (glu_nurbs nurb, unsigned int which)
    quote(call, "  gluNurbsCallback( nurb, which, &c_nurbs_callback );");

quote(ml, "let gluNurbsCallback nurbs which callback =");
quote(ml, "        Callback.register \"ocamlglu_nurbs_cb\" callback; ");
quote(ml, "        _gluNurbsCallback nurbs which;;");


void gluNurbsCallbackData (glu_nurbs nurb, [in, bigarray] void* userData); 
void gluNurbsCallbackDataEXT (glu_nurbs nurb, [in, bigarray] void* userData); 
void gluNurbsCurve (glu_nurbs nurb, int knotCount, 
    [in,bigarray] float knots[], int stride, 
    [in,bigarray] float control[], int order, unsigned int type);
void gluNurbsProperty (glu_nurbs nurb, unsigned int property, float value);
void gluNurbsSurface (glu_nurbs nurb, int sKnotCount, 
    [in,bigarray] float sKnots[], int tKnotCount,
    [in,bigarray] float tKnots[], int sStride, int tStride, 
    [in,bigarray] float control[], int sOrder, int tOrder, 
    unsigned int type);
void gluOrtho2D (double left, double right, double bottom, double top);
void gluPartialDisk (glu_quadric quad, double inner, double outer, int slices, int loops, double start, double sweep);
void gluPerspective (double fovy, double aspect, double zNear, double zFar);
void gluPickMatrix (double x, double y, double delX, double delY,
    [in,*int32,bigarray] int viewport[4]);
idlglu_tf_errcode gluProject (double objX, double objY, double objZ, [in,bigarray] double
model[16], [in,bigarray] double proj[16], [in,bigarray] int view[16], [out, ref] double* winX, [out, ref] double* winY, [out, ref] double* winZ);
void gluPwlCurve (glu_nurbs nurb, int count, [in,bigarray] float data[], int stride, unsigned int type);

// FIXME: Need to be able to handle multiple quadric callbacks.
quote(C, "
static void c_quadric_callback()
{ callback(*caml_named_value(\"ocamlglu_quadric_cb\"), Val_unit); }
");

quote(mli, "val gluQuadricCallback : glu_quadric -> int -> glu_callback -> unit");

void _gluQuadricCallback (glu_quadric quadric, unsigned int which)
    quote(call, "  gluQuadricCallback( quadric, which, &c_quadric_callback );");

quote(ml, "let gluQuadricCallback quadric which callback =");
quote(ml, "        Callback.register \"ocamlglu_quadric_cb\" callback; ");
quote(ml, "        _gluQuadricCallback quadric which;;");

void gluQuadricDrawStyle (glu_quadric quad, unsigned int draw);
void gluQuadricNormals (glu_quadric quad, unsigned int normal);
void gluQuadricOrientation (glu_quadric quad, unsigned int orientation);
void gluQuadricTexture (glu_quadric quad, unsigned char texture);

idlglu_errcode gluScaleImage (int format, int wIn, int hIn, int typeIn, [in,bigarray] void *dataIn, 
    int wOut, int hOut, int typeOut, [in,out,bigarray] void *dataOut);
void gluSphere (glu_quadric quad, double radius, int slices, int stacks);
void gluTessBeginContour (glu_tesselator tess);

/* Callers of gluTessBeginPolygon can emulate the void* data argument using 
   anonymous OCaml functions and closures. */
void gluTessBeginPolygon (glu_tesselator tess) 
    quote(call,"gluTessBeginPolygon(tess, tess);");
void gluBeginPolygon (glu_tesselator tess) 
    quote(call, "gluTessBeginPolygon(tess, tess); gluTessBeginContour(tess);");

void gluTessEndContour (glu_tesselator tess);
void gluTessEndPolygon (glu_tesselator tess);
void gluTessNormal (glu_tesselator tess, double valueX, double valueY, double valueZ);
void gluTessProperty (glu_tesselator tess, unsigned int which, double data);

/*
quote(C,"
static void print_ba(caml_bigarray * ba)
{
    int i;
    GLdouble* data=(GLdouble*)ba->data;
    printf(\"(bigarray %p : data=%p, num_dims=%i, flags=%i, dim[0]=%i\\n\",
        ba, ba->data, ba->num_dims, ba->flags, ba->dim[0]);
    for(i=0; i<ba->dim[0]; i++) {
        printf(\"\t%f\", data[i]);
    }
    printf(\")\\n\");
}
");
*/

void gluTessVertex (glu_tesselator tess, [in,bigarray] double location[], 
    [in, bigarray] double data[]) // FIXME: allow void* data?
    quote(call, "gluTessVertex(tess, location, Bigarray_val(_v_data));");
idlglu_tf_errcode gluUnProject (double winX, double winY, double winZ, [in,bigarray]
    double model[16], [in,bigarray] double proj[16], 
    [in,*int32,bigarray] int view[4], 
    [out,ref] double* objX, [out,ref] double* objY, [out,ref] double* objZ);
idlglu_tf_errcode gluUnProject4 (double winX, double winY, double winZ, double clipW,
    [in,bigarray] double model[16], [in,bigarray] double proj[16], 
    [in,bigarray] int view[16], double near, double far, 
    [out,ref] double* objX, [out,ref] double* objY, [out,ref] double* objZ, 
    [out,ref] double* objW);

quote(mlmli, "
type idlglu_vert_func = f64ba_t -> unit
type idlglu_combine_func = 
    (* coords *) f64ba_t -> 
    (* vertex_data0 *) f64ba_t ->
    (* vertex_data1 *) f64ba_t ->
    (* vertex_data2 *) f64ba_t ->
    (* vertex_data3 *) f64ba_t ->
    (* weight *) f64ba_t -> 
    (* result *) f64ba_t
type glu_tess_callback = 
  GLU_TESS_BEGIN of (* type *) (int -> unit)
| GLU_TESS_EDGE_FLAG of (* flag *) (bool -> unit)
| GLU_TESS_VERTEX of idlglu_vert_func
| GLU_TESS_END of (unit -> unit)
| GLU_TESS_ERROR of (* error number *) (int -> unit)
| GLU_TESS_COMBINE of idlglu_combine_func 
");

quote(C, "
    #include <stdio.h>
static char * ptr2str(void* p)
{
    static char res[80];
    sprintf(res, \"%p\", p);
    return res;
}
");
[string] char * _idlglu_tess_id_str(glu_tesselator tess)
    quote(call, "_res = ptr2str(tess);");

quote(C, "
static char* _cbname(char* kind, char* id)
{
    static char res[80*5];
    sprintf(res, \"idlglu_callback_%s_%s\", kind, id);
    return res;
}
");
[string] char* _cbname([string] char* kind, [string] char *id);

/* Win32 calling conventions. */
#ifndef CALLBACK
#define CALLBACK
#endif

quote(C, "

void CALLBACK idlglu_tess_begin_callback(int msg, void* vp_tess)
{ 
    callback(*caml_named_value(_cbname(\"TessBegin\", ptr2str(vp_tess))), 
        Val_int(msg)); 
}

void CALLBACK idlglu_tess_edge_flag_callback(int msg, void* vp_tess)
{ 
    callback(*caml_named_value(_cbname(\"TessEdgeFlag\", ptr2str(vp_tess))), 
        Val_int(msg)); 
}

void CALLBACK idlglu_tess_vertex_callback(void* vp_bigarray, void* vp_tess)
{ 
    value ba_val;
    struct caml_bigarray* ba=(struct caml_bigarray*) vp_bigarray;
    ba_val = alloc_bigarray(ba->flags, ba->num_dims, ba->data, ba->dim);
    assert(ba->num_dims<=16); /* caml supports no more than 16. */
    callback(*caml_named_value(_cbname(\"TessVertex\", ptr2str(vp_tess))), 
        ba_val);
}

void CALLBACK idlglu_tess_end_callback(int msg, void* vp_tess)
{ 
    callback(*caml_named_value(_cbname(\"TessEnd\", ptr2str(vp_tess))), 
        Val_unit); 
}

void CALLBACK idlglu_tess_error_callback(int msg, void* vp_tess)
{ 
    callback(*caml_named_value(_cbname(\"TessError\", ptr2str(vp_tess))), 
        Val_int(msg)); 
}


void CALLBACK idlglu_tess_combine_callback( GLdouble coords[3], 
    void *vertex_data[4], GLfloat weights[4], void **dataOut, void* vp_tess )
{
    GLdouble *alloc_coords, *alloc_weights;
    value val_args[6], vba_data_out, *cb, vba_coords;
    caml_bigarray* ba;
    int i, k, flags;

    alloc_coords = (GLdouble*) stat_alloc(sizeof(GLdouble)*3);
    alloc_weights = (GLdouble*) stat_alloc(sizeof(GLdouble)*4);
    for(i=0;i<3;i++) { alloc_coords[i] = coords[i]; }
    for(i=0;i<4;i++) { alloc_weights[i] = weights[i]; }

    k=0;
    flags = BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT | BIGARRAY_MANAGED; 
    val_args[k++] = alloc_bigarray_dims(flags, /*numdims*/1, alloc_coords, /*size*/3);

    for(i=0; i<4; i++) {
        struct caml_bigarray* ba = (struct caml_bigarray*)vertex_data[i];
        assert(ba!=NULL);
        assert(ba->num_dims<=8);
        val_args[k++] = alloc_bigarray(ba->flags, ba->num_dims, ba->data, ba->dim);
    }

    val_args[k++]=alloc_bigarray_dims(flags, /*numdims*/1, alloc_weights, /*size*/4);

    cb = caml_named_value(_cbname(\"TessCombine\", ptr2str(vp_tess))); 
    assert(cb!=NULL);
    assert(k==6);
    vba_data_out = callbackN(*cb, k, val_args); /* invoke OCaml callback */

    /* dataOut := result of the OCaml callback */
    ba = Bigarray_val(vba_data_out);
    *dataOut = ba;
}
");

void _gluTessCallback(glu_tesselator tess, int which)
quote(call, "
    switch(which) {
        case GLU_TESS_BEGIN_DATA:       
            gluTessCallback(tess, which, 
                (GLvoid (CALLBACK*) ()) &idlglu_tess_begin_callback);       
            break;
        case GLU_TESS_EDGE_FLAG_DATA:   
            gluTessCallback(tess, which, 
                (GLvoid (CALLBACK*) ()) &idlglu_tess_edge_flag_callback);   
            break;
        case GLU_TESS_VERTEX_DATA:      
            gluTessCallback(tess, which, 
                (GLvoid (CALLBACK*) ()) &idlglu_tess_vertex_callback);      
            break;
        case GLU_TESS_END_DATA:         
            gluTessCallback(tess, which, 
                (GLvoid (CALLBACK*) ()) &idlglu_tess_end_callback);         
            break;
        case GLU_TESS_ERROR_DATA:       
            gluTessCallback(tess, which, 
                (GLvoid (CALLBACK*) ()) &idlglu_tess_error_callback);       
            break;
        case GLU_TESS_COMBINE_DATA:     
            gluTessCallback(tess, which, 
                (GLvoid (CALLBACK*) ()) &idlglu_tess_combine_callback);     
            break;
        default: 
            failwith(\"Invalid callback type in _gluTessCallback\");
    }
");

quote(mli, "
val gluTessCallback : glu_tesselator -> glu_tess_callback -> unit
");

quote(ml, "
let register_cb name cb = Callback.register name cb

let gluTessCallback tess callback =
    let idstr = _idlglu_tess_id_str tess in
    match callback with 
      GLU_TESS_BEGIN cb -> 
        let name = _cbname \"TessBegin\" idstr in
        register_cb name cb;
        _gluTessCallback tess glu_tess_begin_data
    | GLU_TESS_EDGE_FLAG cb -> 
        let name = _cbname \"TessEdgeFlag\" idstr in
        register_cb name (fun i -> cb (i<>0));
        _gluTessCallback tess glu_tess_edge_flag_data
    | GLU_TESS_VERTEX cb -> 
        let name = _cbname \"TessVertex\" idstr in
        register_cb name cb;
        _gluTessCallback tess glu_tess_vertex_data
    | GLU_TESS_END cb -> 
        let name = _cbname \"TessEnd\" idstr in
        register_cb name (fun i -> cb());
        _gluTessCallback tess glu_tess_end_data
    | GLU_TESS_ERROR cb -> 
        let name = _cbname \"TessError\" idstr in
        register_cb name cb;
        _gluTessCallback tess glu_tess_error_data
    | GLU_TESS_COMBINE cb ->
        let name = _cbname \"TessCombine\" idstr in
        register_cb name cb;
        _gluTessCallback tess glu_tess_combine_data
");

